## 垃圾回收算法 ##



引用计数法：给每一个对象添加一个引用计数器，没引用一次计数器加1，当计数器失效计数器减1，任何时刻计数器为0的对象就是不可能被使用的。该算法存在缺陷（无法解决对象循环引用的问题）。

    跟搜索算法：该算法思路就是通过一系列的趁为“GC Roots”的点作为起始进行向下搜索，当一个对象到GC Roots没有任何引用链相连，则证明该对象不可用。

    清除-标记算法：该算法分为标记和清除两个阶段，首先标记出所有需要回收的对象，然后回收所有需要回收的对象。该算法主要有两个缺点一是效率问题，二是空间问题（碎片）。

    复制搜索算法：该算法把可用内存分为两块，每次只用其中的一块，当半区内存用完了，仅将还存活的对象复制到另一块上面，然后就把原来整块内存空间一次清理掉，这样使得每次内存回收都是对整个半区的回收，内存分配时不用考虑内存碎片等问题，该但该算法的代价是将内存缩小为原来的一半。

    分代收集算法：该算法是现在收集器的主流算法（详见上面堆内存）。

垃圾收集器分类：

    Serial收集器：单线程收集器，收集时会暂停所有工作线程，使用复制收集算法，它是虚拟机运行在Client模式时新生代的默认收集器。

    ParNew收集器：该收集器是Serial的多线程版本，它是虚拟机运行在Server模式时新生代的默认收集器。

    Parallel Scavenge收集器：它也是一个多线程的收集器，也是使用复制算法，但是他的对象分配规则和回收策略都与

Serial不同，它是以吞吐量最大化为目标的收集器实现。

    Serial old收集器：该收集器使用标记-清理算法实现，是老年代的收集器。

    Parallel old收集器：老年代版本吞吐量优先收集器，使用多线程和标记-清除算法。JDK1.6提供。

    CMS(Concurrent mark sweep)收集器：是一种以最短停顿时间为目标的收集器。

一般JVM垃圾回收有以下规则：

规则1：一般情况下，对象在eden区分配，当eden无法分配内存时，则触发一次minor GC。

规则2：配置了pretenureSizeThreadholt参数时，对象大于设置值则直接自老年代分配。

规则3：在eden区经过Gc后存活，并且survivor能容纳的对象，将移动到survivor区，如果对象在survivor中继续熬过若干次回收（默认是15次）将会被移到老年代，回收次数由MaxtenuringHold设置。

规则4：如果在survivor空间中相同年龄的所有对象的累计值大于survivor空间的一半时，则这些对象就可以直接进入老年代了，无需达到MaxtenuringHold设置的值。

规则：在minor GC触发时，会检查之前每次晋升到老年代的平均大小是否大于老年代的剩余大小，如果大于改为直接进行Full Gc，如果小于则查看HandlePromotionFailure设置看看是否允许担保失败，入允许则进行minor Gc，反之则进行full gc。