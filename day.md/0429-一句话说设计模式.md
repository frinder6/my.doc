## 设计模式 ##

>看到标题，大家是不是觉得不可思议，java的23种设计模式那么‘复杂’，那么‘难懂’，用一句话怎么说的明白呢？
>首先，各位看官不要误解，近来在回头看设计模式，之前都看过，但时间是把‘杀猪刀’，更是瓶‘健忘药’，特别是对于‘程序猿’来说，有些东西一周不看，就会‘如隔三秋’，本篇旨在用一句话描述一种设计模式，目的仅仅是帮助我们记住每种设计模式是用来做什么的，仅此而已！
>这次的回故让我对设计模式又深入明白了几分，但这里面的水真的太深，理论是一方面，实践才能出真知。
>只有理论联系实践，才能理解的更通透。
>想把设计模式更深入理解，有一个办法，就是去看spring源码，那里面的代码基本都与设计模式有关（个人比较喜欢spring，优秀框架其实都差不多）！

设计模式分类
-
**总体来说设计模式分为三大类：**

- 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

- 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

- 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

- 其实还有两类：并发型模式和线程池模式。

设计模式原则
-

- 开闭原则（Open Close Principle）
- 里氏代换原则（Liskov Substitution Principle）
- 依赖倒转原则（Dependence Inversion Principle）
- 接口隔离原则（Interface Segregation Principle）
- 迪米特法则（最少知道原则）（Demeter Principle）
- 合成复用原则（Composite Reuse Principle）



>以上摘自：[http://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html](http://www.cnblogs.com/maowang1991/archive/2013/04/15/3023236.html)中关于设计模式的分类，这篇博文写的很棒，想要再深入学习的同学赶紧去看看！


一句话工厂模式
-
1. 工厂方法模式（Factory Method）

		使用‘工厂’统一创建实例，一般使用‘静态工厂方法模式’

2. 抽象工厂模式（Abstract Factory）

		其实也属于‘工厂方法模式’，只是针对不同类使用不同的创造工厂，扩展性更好

3. 单例模式（Singleton）

		一个类只能产生一个实例，单例的水很深，可以好好探究下

4. 建造者模式（Builder）

		简单说，就是‘工厂’的‘生产线’，批量生产实例

5. 原型模式（Prototype）

		在原型类的基础上，对类进行深（浅）复制

6. 适配器模式（Adapter）

		将原型A 通过适配器B 转换为消费者C 需要的类型，比如：苹果的充电器（A）使用适配器(B)使用中国的线插(C)一样

7. 装饰模式（Decorator）

		通过装饰器A 为目标对象B 增加一些新的功能，关注点在‘新功能’

8. 代理模式（Proxy）

		通过调用代理A 实现调用目标对象B 的目的

>装饰模式与代理模式的区别

	1. 装饰模式关注的是在一个对象上‘添加新功能’；代理关注的是‘控制对象访问’
	2. 装饰模式将目标对象作为构造器参数；代理模式在代理类中创建目标对象实例，对外隐藏目标对象
	3. 代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造

9. 外观模式（Facade）

		通过组件A 将元件B/C/D 组装起来，实现特定功能，如：机箱将CPU，主板，硬盘等元件组装起来，从而使电脑能够正常运行

10. 桥接模式（Bridge）

		抽象出公共通道A和公共标准B，所有标准B 的实现，都能以相同的方式通过通道A

>桥接模式确实很抽象

	如：坐落在河面的桥（公共通道A），不管bus/car还是truck（具体实现），只要遵循交通规则（行车规则即公共标准B），都能安全通过；
	再如：jdbc连接，公共通道DriverManager与公共标准Driver，具体实现如MysqlDriver、OracleDriver等，都能以同样的方式被DriverManager管理；

11. 组合模式（Composite）

		学习中...

12. 享元模式（Flyweight）

		实现对象共享，共享池技术一般都采用享元模式实现

13. 策略模式（strategy）

		针对不同策略提供具体实现，根据策略选择相应实现；如：计算器的+-*/，用户选择+，系统会调用对应+的具体实现，扩展到其它场景也一样

14. 模板方法模式（Template Method）

		基类中定义主方法和抽象方法，并且主方法调用抽象方法，子类中具体实现抽象方法并加入相应策略，使所有实现的子类在调用时感觉在使用模板一样（语言很难表达清楚，还是看代码理解的快）
		
15. 观察者模式（Observer）

		为目标对象添加一个或多个观察者，并且目标对象在操作时通知所有观察者--我修改了

16. 迭代子模式（Iterator）
		
		模拟集合对目标对象进行操作

17. 责任链模式（Chain of Responsibility）

		调用者A，调用对象B，对象B 中有对象C 的引用，于是对象C 被调用，对象C 中有对象D 的引用，于是对象D 被调用...

18. 命令模式（Command）

		命令发出者A 发出指令给传递者B，传递者B 将指令给执行者C，A 并不关心C 如何完成任务
		
19. 备忘录模式（Memento）

		目标对象A 的状态S 保存在备忘对象B 中，辅助类 C保存备忘对象 B，当A 状态改变后，通过备忘对象找回原状态

20. 状态模式（State）

		通过不同状态控制不同行为

21. 访问者模式（Visitor）

		通过新增目标对象来实现新的操作，不影响原有操作与行为

22. 中介者模式（Mediator）

		添加中介对象实现目标对象的操作，达到解藕目的

23. 解释器模式（Interpreter）

		通过解释器A 将目标对象 B进行解释，如：计算解释、正则解释等


>不写不知道，一句话来说设计模式真心太难了，根本说不清楚！
>很多可能解释的并不清晰，我自己也很难理解，后续再整理与修改！
>还是那句，记住一句话，就记住一种设计模式，这是目标，任重道远！

加油！！！